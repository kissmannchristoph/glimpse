name: Gemini Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  code-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        run: |
          # Get the list of changed files
          git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          echo "Files changed:"
          cat changed_files.txt

      - name: Filter reviewable files
        id: filter-files
        run: |
          # Filter to only include code files that Gemini can review
          # Supported extensions
          SUPPORTED_EXTS="rs|py|js|ts|jsx|tsx|go|java|cpp|c|h|hpp|cs|rb|php|swift|kt|scala|sh|bash|yaml|yml|json|toml|sql|md|txt"
          
          # Filter files
          grep -E "\.(${SUPPORTED_EXTS})$" changed_files.txt > reviewable_files.txt || true
          
          # Check if we have any files to review
          if [ ! -s reviewable_files.txt ]; then
            echo "has_reviewable_files=false" >> $GITHUB_OUTPUT
            echo "No reviewable code files found in this PR"
          else
            echo "has_reviewable_files=true" >> $GITHUB_OUTPUT
            echo "Reviewable files:"
            cat reviewable_files.txt
          fi

      - name: Get file contents and diff
        id: get-diff
        if: steps.filter-files.outputs.has_reviewable_files == 'true'
        run: |
          # Create a file with all diffs
          echo "## Code Changes for Review" > review_context.txt
          echo "" >> review_context.txt
          
          # Limit diff size to avoid token limits
          MAX_FILES=15
          COUNT=0
          
          while IFS= read -r file && [ $COUNT -lt $MAX_FILES ]; do
            if [ -f "$file" ]; then
              # Get file size
              SIZE=$(wc -c < "$file" 2>/dev/null || echo 0)
              
              # Skip very large files (> 100KB)
              if [ "$SIZE" -lt 102400 ]; then
                echo "### File: $file" >> review_context.txt
                echo '```diff' >> review_context.txt
                git diff origin/${{ github.base_ref }}...HEAD -- "$file" >> review_context.txt
                echo '```' >> review_context.txt
                echo "" >> review_context.txt
                COUNT=$((COUNT + 1))
              else
                echo "### File: $file (skipped - too large)" >> review_context.txt
                echo "" >> review_context.txt
              fi
            fi
          done < reviewable_files.txt
          
          if [ $COUNT -eq 0 ]; then
            echo "has_diff=false" >> $GITHUB_OUTPUT
          else
            echo "has_diff=true" >> $GITHUB_OUTPUT
          fi

      - name: Review code with Gemini
        id: gemini-review
        if: steps.get-diff.outputs.has_diff == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # Read the diff content
          DIFF_CONTENT=$(cat review_context.txt)
          
          # Create JSON payload for Gemini API
          cat > request.json <<EOF
          {
            "contents": [{
              "parts": [{
                "text": "You are an expert code reviewer. Review the following code changes and provide constructive feedback. Focus on:\n\n1. Code quality and best practices\n2. Potential bugs or issues\n3. Performance concerns\n4. Security vulnerabilities\n5. Code style and readability\n6. Suggestions for improvement\n\nProvide your review in a clear, constructive manner. Use markdown formatting.\n\n${DIFF_CONTENT}"
              }]
            }],
            "generationConfig": {
              "temperature": 0.4,
              "topK": 32,
              "topP": 1,
              "maxOutputTokens": 4096
            }
          }
          EOF
          
          # Call Gemini API
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}" \
            -H 'Content-Type: application/json' \
            -d @request.json)
          
          # Extract the review text from JSON response
          REVIEW=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "Error: Could not generate review"')
          
          # Save review to file
          echo "$REVIEW" > review.txt
          
          # Also save to GitHub output (escaped for multiline)
          echo "review<<EOF" >> $GITHUB_OUTPUT
          echo "$REVIEW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post review comment
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            let body;
            if ('${{ steps.filter-files.outputs.has_reviewable_files }}' === 'false') {
              body = `##  Gemini AI Code Review\n\n` +
                     `對 No reviewable code files found in this PR.\n\n` +
                     `Gemini can review: Rust, Python, JavaScript/TypeScript, Go, Java, C/C++, C#, Ruby, PHP, Swift, Kotlin, Scala, Shell scripts, YAML, JSON, TOML, SQL, and Markdown files.\n\n` +
                     `If you believe this is an error, please check the workflow configuration.`;
            } else if ('${{ steps.get-diff.outputs.has_diff }}' === 'false') {
              body = `##  Gemini AI Code Review\n\n` +
                     `對 All changed files were too large to review or were filtered out.\n\n` +
                     `Files larger than 100KB are skipped to avoid API limits.`;
            } else {
              const review = fs.readFileSync('review.txt', 'utf8');
              body = `##  Gemini AI Code Review\n\n${review}\n\n---\n*Powered by Google Gemini 1.5 Flash*`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });